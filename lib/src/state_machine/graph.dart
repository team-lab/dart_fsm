part of 'state_machine.dart';

/// A class representing state transitions
/// It has a map representing the pattern of state transitions
final class Graph<STATE extends StateMachineState,
    ACTION extends StateMachineAction> {
  /// Creates a new graph with the given transition pattern map
  const Graph(this.transitionPatternMap);

  /// A map of [Matcher<STATE>] and [GraphState<STATE, ACTION>]
  /// Specify the transition before the state with [Matcher<STATE>], and
  /// specify the action required for the transition and the state after the
  /// transition with [GraphState<STATE, ACTION>]
  /// Generated by GraphBuilder
  final Map<Matcher<STATE>, GraphState<STATE, ACTION>> transitionPatternMap;
}

/// A class representing the information of which state to transition to when a
/// particular action is dispatched
/// As for the information of the state before the transition, it is specified
/// in the transitionPatternMap of Graph, so here, it holds the information of
/// the action required for the transition and the state after the transition
/// Generated by StateConfigBuilder
final class GraphState<STATE extends StateMachineState,
    ACTION extends StateMachineAction> {
  /// Creates a new graph state with the given transition map
  const GraphState(this.transitionMap);

  /// A map of [Matcher<ACTION>] and
  /// [StateTransitionFunction<STATE, ACTION, STATE>]. Specify the action
  /// required for the transition with [Matcher<ACTION>], and specify the state
  /// after the transition with [StateTransitionFunction<STATE, ACTION, STATE>]
  /// Generated by StateConfigBuilder.
  /// The state before the transition is specified in the transitionPatternMap
  /// of Graph so here, it holds the information of the action required for the
  /// transition and the state after the transition.
  final Map<Matcher<ACTION>, StateTransitionFunction<STATE, ACTION, STATE>>
      transitionMap;
}

/// A function that takes the state before the transition and the action and
/// returns the new state after the transition in the form of [TransitionTo]
typedef StateTransitionFunction<STATE extends StateMachineState,
        ACTION extends StateMachineAction, ON_STATE extends STATE>
    = TransitionTo<STATE> Function(ON_STATE currentState, ACTION action);

/// A class representing the state after the
final class TransitionTo<STATE extends StateMachineState> {
  /// Creates a new transition to with the given state
  const TransitionTo(this.toState);

  /// The state after the transition
  final STATE toState;
}

/// A parent class for representing state transition patterns
/// It is common to have the state before the transition and the action, and
/// this class is inherited by Valid and Invalid to branch.
sealed class Transition<STATE extends StateMachineState,
    ACTION extends StateMachineAction> {
  const Transition(this.fromState, this.action);

  /// The state before the transition
  final STATE fromState;

  /// The action when the transition is made
  final ACTION action;
}

/// A class representing the state transition pattern when the transition is
/// valid. In addition to the state before the transition and the action, it
/// also holds the state after the transition. The state before the transition
/// and the action are inherited from Transition, and the state after the
/// transition is added.
final class Valid<STATE extends StateMachineState,
    ACTION extends StateMachineAction> extends Transition<STATE, ACTION> {
  /// Creates a new valid transition with the given state
  const Valid(super.fromState, super.action, this.toState);

  /// The state after the transition
  final STATE toState;
}

/// A class representing the state transition pattern when the transition is
/// invalid. It has the same state before the transition and the action as
/// Transition, but it does not have the state after the transition.
final class Invalid<STATE extends StateMachineState,
    ACTION extends StateMachineAction> extends Transition<STATE, ACTION> {
  /// Creates a new invalid transition
  const Invalid(super.fromState, super.action);
}

/// A class that performs type matching.
/// By specifying this as the key of a Map, you can write branching logic that
final class Matcher<T> {
  /// Creates a new matcher
  const Matcher();

  /// Returns true if the given value matches the type T
  bool matches(dynamic value) {
    final result = value is T;
    return result;
  }
}

/// The type of function that the Builder for building the Graph receives
typedef StateConfigBuilderFunction<STATE extends StateMachineState,
        ACTION extends StateMachineAction, ON_STATE extends STATE>
    = StateConfigBuilder<STATE, ACTION, ON_STATE> Function(
  StateConfigBuilder<STATE, ACTION, ON_STATE>,
);

/// A builder for building the [Graph]
class GraphBuilder<STATE extends StateMachineState,
    ACTION extends StateMachineAction> {
  ///
  final Map<Matcher<STATE>, GraphState<STATE, ACTION>> _stateConfigMap = {};

  /// Used to define actions that can be taken in a specific state.
  /// When ON_STATE and ON_ACTION are dispatched, transition to the state
  /// specified in transition.
  void state<ON_STATE extends STATE>(
    StateConfigBuilderFunction<STATE, ACTION, ON_STATE> stateConfigBuilder,
  ) {
    // Generate a StateConfigBuilder here and register it in the Map
    _stateConfigMap[Matcher<ON_STATE>()] =
        stateConfigBuilder(StateConfigBuilder<STATE, ACTION, ON_STATE>())
            .build();
  }

  /// Builds a Graph
  Graph<STATE, ACTION> build() {
    return Graph<STATE, ACTION>(_stateConfigMap);
  }
}

/// Builder for building [GraphState]
class StateConfigBuilder<STATE extends StateMachineState,
    ACTION extends StateMachineAction, ON_STATE extends STATE> {
  final GraphState<STATE, ACTION> _stateFactor = GraphState<STATE, ACTION>({});

  /// When a specific Action is dispatched, transition to the State specified in
  /// transition.
  void on<ON_ACTION extends ACTION>(
    StateTransitionFunction<STATE, ON_ACTION, ON_STATE> transition,
  ) {
    _stateFactor.transitionMap[Matcher<ON_ACTION>()] = (currentState, action) {
      return transition(currentState as ON_STATE, action as ON_ACTION);
    };
  }

  /// Use this when you want to execute AfterSideEffect without transitioning
  void noTransitionOn<ON_ACTION extends ACTION>() {
    _stateFactor.transitionMap[Matcher<ON_ACTION>()] = (currentState, action) {
      return TransitionTo(currentState as ON_STATE);
    };
  }

  /// When any Action is dispatched, transition to the State specified in
  /// transition.
  void onAny(StateTransitionFunction<STATE, ACTION, ON_STATE> transition) {
    on(transition);
  }

  /// Builds a GraphState
  GraphState<STATE, ACTION> build() {
    return _stateFactor;
  }

  /// A function to specify the state after the transition
  TransitionTo<STATE> transitionTo(STATE newState) {
    return TransitionTo(newState);
  }
}
